#!/usr/bin/env python3
"""
Emm42 V5.0 Plugin Simple Tester
Testing utility for the Emm42 V5.0 stepper motor plugin
"""

import sys
import os
import time
from datetime import datetime

# Add the current directory to path to import local modules
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    from plugins.emm42_v5 import Plugin as Emm42Plugin
    from plugin_system import ChecksumCalculator
except ImportError as e:
    print(f"Import error: {e}")
    print("Make sure the plugin files are in the correct location")
    sys.exit(1)


class SimpleEmm42Tester:
    """Simple tester for Emm42 V5.0 plugin"""
    
    def __init__(self):
        self.plugin = Emm42Plugin()
        self.test_results = []
        print(f"Loaded plugin: {self.plugin.name}")
        print(f"Description: {self.plugin.description}")
    
    def test_command_generation(self, command, parameters=None):
        """Test command generation and parsing"""
        if parameters is None:
            parameters = {}
        
        print(f"\n{'='*50}")
        print(f"Testing command: {command}")
        print(f"Parameters: {parameters}")
        
        try:
            # Generate command bytes
            cmd_bytes = self.plugin.process_command(command, parameters)
            hex_str = ' '.join([f'{b:02X}' for b in cmd_bytes])
            print(f"Generated bytes: {hex_str}")
            
            # Test parsing a mock response
            mock_response = self.generate_mock_response(command, parameters.get('address', 1))
            if mock_response:
                resp_hex = ' '.join([f'{b:02X}' for b in mock_response])
                print(f"Mock response: {resp_hex}")
                
                # Parse with plugin
                parsed = self.plugin.parse_response(mock_response)
                print(f"Parsed response: {parsed}")
                
                # Test human-readable conversion if available
                if hasattr(self.plugin, 'response_to_human_readable'):
                    human_readable = self.plugin.response_to_human_readable(mock_response)
                    print(f"Human readable: {human_readable}")
            
            return True, cmd_bytes, mock_response
            
        except Exception as e:
            print(f"ERROR: {e}")
            return False, None, None
    
    def generate_mock_response(self, command, address):
        """Generate realistic mock responses for testing"""
        responses = {
            'motor_enable': bytes([address, 0xF3, 0x02, 0x6B]),
            'speed_mode': bytes([address, 0xF6, 0x02, 0x6B]),
            'position_mode': bytes([address, 0xFD, 0x02, 0x6B]),
            'immediate_stop': bytes([address, 0xFE, 0x02, 0x6B]),
            'read_encoder_value': bytes([address, 0x31, 0x1A, 0x2B, 0x6B]),
            'read_motor_status': bytes([address, 0x3A, 0x03, 0x6B]),
            'read_realtime_speed': bytes([address, 0x35, 0x00, 0x00, 0x64, 0x6B]),
            'read_firmware_version': bytes([address, 0x1F, 0x20, 0x15, 0x6B]),
        }
        
        return responses.get(command)
    
    def test_all_basic_commands(self):
        """Test all basic command types"""
        print("\n" + "="*60)
        print("TESTING BASIC COMMANDS")
        print("="*60)
        
        test_cases = [
            # Control commands
            ('motor_enable', {'address': 1, 'enable': 'Enable', 'sync': 'No'}),
            ('motor_enable', {'address': 1, 'enable': 'Disable', 'sync': 'No'}),
            ('speed_mode', {'address': 1, 'direction': 'CW', 'speed': 100, 'acceleration': 10}),
            ('position_mode', {'address': 1, 'direction': 'CW', 'speed': 100, 'pulses': 3200}),
            ('immediate_stop', {'address': 1}),
            
            # Homing commands
            ('trigger_homing', {'address': 1, 'mode': 'Nearest'}),
            ('stop_homing', {'address': 1}),
            ('set_zero_position', {'address': 1, 'save': 'Yes'}),
            
            # Utility commands
            ('calibrate_encoder', {'address': 1}),
            ('clear_position', {'address': 1}),
            ('clear_stall_protection', {'address': 1}),
            ('factory_reset', {'address': 1}),
        ]
        
        for command, params in test_cases:
            success, cmd_bytes, response = self.test_command_generation(command, params)
            self.test_results.append({
                'command': command,
                'success': success,
                'parameters': params
            })
    
    def test_read_commands(self):
        """Test all read commands"""
        print("\n" + "="*60)
        print("TESTING READ COMMANDS")
        print("="*60)
        
        read_commands = [
            'read_firmware_version',
            'read_motor_params',
            'read_pid_params', 
            'read_bus_voltage',
            'read_phase_current',
            'read_encoder_value',
            'read_input_pulses',
            'read_target_position',
            'read_realtime_speed',
            'read_realtime_position',
            'read_motor_status',
            'read_homing_status'
        ]
        
        for command in read_commands:
            success, cmd_bytes, response = self.test_command_generation(command, {'address': 1})
            self.test_results.append({
                'command': command,
                'success': success,
                'parameters': {'address': 1}
            })
    
    def test_modify_commands(self):
        """Test modify parameter commands"""
        print("\n" + "="*60)
        print("TESTING MODIFY COMMANDS")
        print("="*60)
        
        modify_cases = [
            ('modify_subdivision', {'address': 1, 'save': 'Yes', 'subdivision': 32}),
            ('modify_id_address', {'address': 1, 'save': 'No', 'new_id': 2}),
            ('switch_open_closed_loop', {'address': 1, 'save': 'Yes', 'mode': 'Closed Loop'}),
            ('modify_open_loop_current', {'address': 1, 'save': 'No', 'current': 1500}),
            ('store_speed_params', {'address': 1, 'operation': 'Store', 'speed': 200}),
        ]
        
        for command, params in modify_cases:
            success, cmd_bytes, response = self.test_command_generation(command, params)
            self.test_results.append({
                'command': command,
                'success': success,
                'parameters': params
            })
    
    def test_checksum_types(self):
        """Test different checksum types"""
        print("\n" + "="*60)
        print("TESTING CHECKSUM TYPES")
        print("="*60)
        
        checksum_types = ['fixed_0x6B', 'xor', 'crc8']
        
        for checksum_type in checksum_types:
            print(f"\nTesting checksum type: {checksum_type}")
            params = {
                'address': 1,
                'enable': 'Enable',
                'checksum_type': checksum_type
            }
            success, cmd_bytes, response = self.test_command_generation('motor_enable', params)
            self.test_results.append({
                'command': f'motor_enable_{checksum_type}',
                'success': success,
                'parameters': params
            })
    
    def test_custom_commands(self):
        """Test custom command functionality"""
        print("\n" + "="*60)
        print("TESTING CUSTOM COMMANDS")
        print("="*60)
        
        custom_cases = [
            {
                'address': 1,
                'func_code': 0x06,
                'data': '45',
                'checksum_type': 'fixed_0x6B'
            },
            {
                'address': 1,
                'func_code': 0x84,
                'data': '8A 01 20',
                'checksum_type': 'xor'
            }
        ]
        
        for params in custom_cases:
            success, cmd_bytes, response = self.test_command_generation('custom_command', params)
            self.test_results.append({
                'command': 'custom_command',
                'success': success,
                'parameters': params
            })
    
    def test_parameter_validation(self):
        """Test parameter validation"""
        print("\n" + "="*60)
        print("TESTING PARAMETER VALIDATION")
        print("="*60)
        
        # Test valid parameters
        valid_params = {'address': 1, 'enable': 'Enable'}
        is_valid = self.plugin.validate_parameters('motor_enable', valid_params)
        print(f"Valid parameters test: {'PASS' if is_valid else 'FAIL'}")
        
        # Test invalid parameters (if validation is implemented)
        invalid_params = {'address': 300, 'enable': 'Invalid'}  # Address out of range
        is_valid = self.plugin.validate_parameters('motor_enable', invalid_params)
        print(f"Invalid parameters test: {'PASS' if not is_valid else 'FAIL'}")
    
    def test_response_parsing(self):
        """Test response parsing with various response types"""
        print("\n" + "="*60)
        print("TESTING RESPONSE PARSING")
        print("="*60)
        
        test_responses = [
            # Success response
            (bytes([0x01, 0xF3, 0x02, 0x6B]), "Success response"),
            # Error response  
            (bytes([0x01, 0x00, 0xEE, 0x6B]), "Error response"),
            # Encoder value response
            (bytes([0x01, 0x31, 0x1A, 0x2B, 0x6B]), "Encoder value"),
            # Motor status response
            (bytes([0x01, 0x3A, 0x03, 0x6B]), "Motor status"),
            # Short response (error case)
            (bytes([0x01]), "Short response"),
        ]
        
        for response_bytes, description in test_responses:
            print(f"\nTesting {description}:")
            hex_str = ' '.join([f'{b:02X}' for b in response_bytes])
            print(f"Response bytes: {hex_str}")
            
            try:
                parsed = self.plugin.parse_response(response_bytes)
                print(f"Parsed: {parsed}")
                
                if hasattr(self.plugin, 'response_to_human_readable'):
                    human_readable = self.plugin.response_to_human_readable(response_bytes)
                    print(f"Human readable: {human_readable}")
                    
            except Exception as e:
                print(f"Error parsing: {e}")
    
    def run_all_tests(self):
        """Run complete test suite"""
        print("Emm42 V5.0 Plugin Comprehensive Tester")
        print("="*60)
        
        start_time = time.time()
        
        self.test_all_basic_commands()
        self.test_read_commands()
        self.test_modify_commands()
        self.test_checksum_types()
        self.test_custom_commands()
        self.test_parameter_validation()
        self.test_response_parsing()
        
        end_time = time.time()
        self.print_summary(end_time - start_time)
    
    def print_summary(self, duration):
        """Print test summary"""
        print("\n" + "="*60)
        print("TEST SUMMARY")
        print("="*60)
        
        total_tests = len(self.test_results)
        passed_tests = sum(1 for result in self.test_results if result['success'])
        failed_tests = total_tests - passed_tests
        
        print(f"Total tests: {total_tests}")
        print(f"Passed: {passed_tests}")
        print(f"Failed: {failed_tests}")
        print(f"Success rate: {(passed_tests/total_tests)*100:.1f}%" if total_tests > 0 else "No tests run")
        print(f"Duration: {duration:.2f} seconds")
        
        if failed_tests > 0:
            print(f"\nFailed tests:")
            for result in self.test_results:
                if not result['success']:
                    print(f"  - {result['command']}")
    
    def demo_commands(self):
        """Demonstrate key commands with detailed output"""
        print("\n" + "="*60)
        print("COMMAND DEMONSTRATION")
        print("="*60)
        
        demos = [
            # Motor control demo
            ('motor_enable', {'address': 1, 'enable': 'Enable', 'sync': 'No'}),
            ('speed_mode', {'address': 1, 'direction': 'CW', 'speed': 150, 'acceleration': 15}),
            ('position_mode', {'address': 1, 'direction': 'CCW', 'speed': 100, 'pulses': 6400, 'mode': 'Relative'}),
            ('immediate_stop', {'address': 1, 'sync': 'No'}),
            
            # Status reading demo
            ('read_motor_status', {'address': 1}),
            ('read_realtime_speed', {'address': 1}),
            ('read_realtime_position', {'address': 1}),
            
            # Homing demo
            ('trigger_homing', {'address': 1, 'mode': 'Direction', 'sync': 'No'}),
            ('read_homing_status', {'address': 1}),
        ]
        
        for command, params in demos:
            print(f"\n--- Demonstrating: {command} ---")
            print(f"Purpose: {self.plugin.get_commands()[command]['description']}")
            self.test_command_generation(command, params)


def print_plugin_info():
    """Print detailed plugin information"""
    plugin = Emm42Plugin()
    commands = plugin.get_commands()
    
    print("Emm42 V5.0 Plugin Information")
    print("="*60)
    print(f"Name: {plugin.name}")
    print(f"Description: {plugin.description}")
    print(f"Total commands: {len(commands)}")
    
    print(f"\nCommand categories:")
    categories = {}
    for cmd_name, cmd_info in commands.items():
        desc = cmd_info.get('description', '')
        if 'read' in cmd_name.lower():
            category = 'Read Commands'
        elif 'modify' in cmd_name.lower() or 'store' in cmd_name.lower() or 'switch' in cmd_name.lower():
            category = 'Modify Commands'
        elif 'homing' in cmd_name.lower() or 'zero' in cmd_name.lower():
            category = 'Homing Commands'
        elif cmd_name in ['motor_enable', 'speed_mode', 'position_mode', 'immediate_stop', 'sync_motion']:
            category = 'Control Commands'
        elif cmd_name in ['calibrate_encoder', 'clear_position', 'clear_stall_protection', 'factory_reset']:
            category = 'Utility Commands'
        else:
            category = 'Other Commands'
        
        if category not in categories:
            categories[category] = []
        categories[category].append(cmd_name)
    
    for category, cmd_list in categories.items():
        print(f"  {category}: {len(cmd_list)} commands")
        for cmd in cmd_list[:3]:  # Show first 3 commands
            print(f"    - {cmd}")
        if len(cmd_list) > 3:
            print(f"    - ... and {len(cmd_list) - 3} more")
        print()


def main():
    """Main function"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Emm42 V5.0 Plugin Tester")
    parser.add_argument("--demo", action="store_true", help="Run command demonstrations")
    parser.add_argument("--info", action="store_true", help="Show plugin information")
    parser.add_argument("--test", choices=['basic', 'read', 'modify', 'checksum', 'custom', 'all'], 
                       default='all', help="Which tests to run")
    
    args = parser.parse_args()
    
    if args.info:
        print_plugin_info()
        return
    
    tester = SimpleEmm42Tester()
    
    if args.demo:
        tester.demo_commands()
        return
    
    if args.test == 'all':
        tester.run_all_tests()
    elif args.test == 'basic':
        tester.test_all_basic_commands()
        tester.print_summary(0)
    elif args.test == 'read':
        tester.test_read_commands()
        tester.print_summary(0)
    elif args.test == 'modify':
        tester.test_modify_commands()
        tester.print_summary(0)
    elif args.test == 'checksum':
        tester.test_checksum_types()
        tester.print_summary(0)
    elif args.test == 'custom':
        tester.test_custom_commands()
        tester.print_summary(0)


if __name__ == "__main__":
    main()
